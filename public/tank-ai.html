<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>Tank | Bricks Game (Optimized)</title>
  <style>
    :root {
      --main-bg-color: #bfc8b2;
      --deem-color: #9da591;
      --dark-color: #000000;
      --food-color: #661091;
      --pixel-size: 0.6em;
      --pixel-border-size: 0.2em;
    }
    div { float: left; }
    span {
      border: var(--pixel-border-size) solid var(--main-bg-color);
      outline: var(--pixel-border-size) solid var(--deem-color);
      background-color: var(--deem-color);
      content: " ";
      display: block;
      width: var(--pixel-size);
      height: var(--pixel-size);
      margin: 0.15em;
    }
    .active { outline-color: var(--dark-color); background-color: var(--dark-color); }
    .food { outline-color: var(--food-color); background-color: var(--food-color); }
    table { background-color: var(--main-bg-color); border: .1em solid; }
  </style>
</head>
<body>
  <div id="gamepanel"></div>

  <script>
    /*******************
     * UI helpers (unchanged API)
     *******************/
    const tags = [
      {id : 'score', text: 'Score: ', value: 0},
      {id : 'level', text: 'Level: ', value: 0},
      {id : 'message', text: 'Message: ', value: ''},
    ];

    const buttons = [
      {id: "restart", name: "Restart", callback: "init()", text: "Restart: ", optionalKey: "[R / Del]", initDisplayNone: false},
      {id: "pause", name: "Pause", callback: "pause()", text: "Pause: ", optionalKey: "[Enter]", initDisplayNone: false},
      {id: "resume", name: "Resume", callback: "resume()", text: "Resume: ", optionalKey: "[Enter]", initDisplayNone: true},
    ];

    const links = [
      {id: "snake", name: "Snake", url: "./snake.html"},
      {id: "tetris", name: "Tetris", url: "./tetris.html"},
      {id: "frogger", name: "Frogger", url: "./frogger.html"},
      {id: "tank", name: "Tank [Beta]", url: "./tank.html"},
      {id: "racing", name: "Racing", url: "./racing.html"}
    ];

    function getTableRow(cb) {
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      cb(tr, td);
      tr.appendChild(td);
      return tr;
    }

    function getTextElement(id, name, isBold) {
      const text = document.createElement("text");
      if (id) text.id = id;
      text.innerText = name;
      if (isBold) text.style = "font-weight: bold;";
      return text;
    }

    function getButtonElement(name, callback) {
      const button = document.createElement("button");
      button.id = name.toLowerCase() + "btn";
      button.innerText = name;
      button.setAttribute('onclick', callback);
      return button;
    }

    function setupResultScreen(name) {
      const panelDiv = document.createElement("div");
      const table2 = document.createElement("table");
      table2.style = "padding: 1em;";

      table2.appendChild(getTableRow((tr, td) => {
        const h1 = document.createElement("h1");
        h1.innerText = name + " Game";
        td.appendChild(h1);
      }));

      for (const tag of tags) {
        table2.appendChild(getTableRow((tr, td) => {
          td.appendChild(getTextElement(null, tag.text, false));
          td.appendChild(getTextElement(tag.id, tag.value, true));
        }));
      }

      for (const btn of buttons) {
        table2.appendChild(getTableRow((tr, td) => {
          td.appendChild(getTextElement(null, btn.text, false));
          td.appendChild(getButtonElement(btn.name, btn.callback));
          td.appendChild(getTextElement(null, btn.optionalKey, true));
          if (btn.initDisplayNone) tr.style = "display: none;";
          tr.id = btn.id;
        }));
      }

      table2.appendChild(getTableRow((tr, td) => { td.appendChild(document.createElement("hr")); }));
      table2.appendChild(getTableRow((tr, td) => { const h3 = document.createElement("h3"); h3.innerText = "Other Games"; td.appendChild(h3); }));
      for (const link of links) {
        table2.appendChild(getTableRow((tr, td) => {
          const a = document.createElement("a"); a.href = link.url; a.innerText = link.name; if (name.toLowerCase() === link.id) a.style = "font-weight: bold;"; td.appendChild(a);
        }));
      }

      panelDiv.appendChild(table2);
      return panelDiv;
    }

    /*******************
     * Optimized renderer state
     *******************/
    const W = 10, H = 20;
    let grid = Array.from({ length: H }, () => Array(W).fill(""));
    let pixels = []; // cached DOM spans [y][x]

    function setupGameScreen() {
      const containerDiv = document.createElement("div");
      const table = document.createElement("table");
      for (let y = 0; y < H; y++) {
        const tr = document.createElement("tr");
        pixels[y] = [];
        for (let x = 0; x < W; x++) {
          const td = document.createElement("td");
          const span = document.createElement("span");
          span.id = `pixel_${x}_${y}`;
          td.appendChild(span);
          tr.appendChild(td);
          pixels[y][x] = span; // cache DOM reference
        }
        table.appendChild(tr);
      }
      containerDiv.appendChild(table);
      return containerDiv;
    }

    function renderGrid() {
      // Write all classes in one tight loop
      for (let y = 0; y < H; y++) {
        const row = grid[y];
        const prow = pixels[y];
        for (let x = 0; x < W; x++) {
          // Avoid layout thrash: just set className (cheap)
          prow[x].className = row[x];
        }
      }
    }

    function clearGrid() {
      for (let y = 0; y < H; y++) grid[y].fill("");
    }

    function mark(x, y, cls = "active") {
      if (x >= 0 && x < W && y >= 0 && y < H) grid[y][x] = cls;
    }

    function markCoords(coords, cls = "active") {
      for (const c of coords) mark(c.x, c.y, cls);
    }

    function setupGamePanel(name) {
      document.title = name + " | Bricks Game";
      const gamePanelDiv = document.getElementById("gamepanel");
      gamePanelDiv.appendChild(setupGameScreen());
      gamePanelDiv.appendChild(setupResultScreen(name));
    }

    /*******************
     * Classes (logic only; no DOM in methods)
     *******************/
    class Bullet {
      constructor(pos_x, pos_y, direction) { this.pos_x = pos_x; this.pos_y = pos_y; this.direction = direction; }
      moveForward() {
        if (this.direction === "up") this.pos_y--; else if (this.direction === "down") this.pos_y++; else if (this.direction === "left") this.pos_x--; else if (this.direction === "right") this.pos_x++;
        return this;
      }
      isValid() { return !(this.pos_x < 0 || this.pos_x >= W || this.pos_y < 0 || this.pos_y >= H); }
      off() { this.pos_x = -1; this.pos_y = -1; }
    }

    class Tank {
      constructor(pos_x, pos_y, is_enemy, direction) { this.pos_x = pos_x; this.pos_y = pos_y; this.is_enemy = is_enemy; this.direction = direction; }

      move(dir) {
        // Bound-aware movement only if continuing in same direction (matches original intent)
        if (dir === "up") { if (this.direction === "up" && this.pos_y > 1) this.pos_y--; }
        else if (dir === "down") { if (this.direction === "down" && this.pos_y < H - 2) this.pos_y++; }
        else if (dir === "left") { if (this.direction === "left" && this.pos_x > 1) this.pos_x--; }
        else if (dir === "right") { if (this.direction === "right" && this.pos_x < W - 2) this.pos_x++; }
        this.direction = dir;
        return this;
      }

      getCordinates() {
        const cords = [];
        const x = this.pos_x, y = this.pos_y, d = this.direction;
        if (d === "up") {
          cords.push({x, y: y - 1}, {x: x - 1, y: y + 1}, {x: x + 1, y: y + 1});
          if (!this.is_enemy) cords.push({x, y: y + 1});
        } else if (d === "down") {
          cords.push({x, y: y + 1}, {x: x - 1, y: y - 1}, {x: x + 1, y: y - 1});
          if (!this.is_enemy) cords.push({x, y: y - 1});
        } else if (d === "left") {
          cords.push({x: x - 1, y}, {x: x + 1, y: y - 1}, {x: x + 1, y: y + 1});
          if (!this.is_enemy) cords.push({x: x + 1, y});
        } else if (d === "right") {
          cords.push({x: x + 1, y}, {x: x - 1, y: y - 1}, {x: x - 1, y: y + 1});
          if (!this.is_enemy) cords.push({x: x - 1, y});
        }
        if (d === "up" || d === "down") { cords.push({x: x - 1, y}, {x: x + 1, y}); }
        else { cords.push({x, y: y - 1}, {x, y: y + 1}); }
        cords.push({x, y});
        return cords;
      }

      getBullet() {
        let bx = this.pos_x, by = this.pos_y;
        if (this.direction === "up") by -= 2; else if (this.direction === "down") by += 2; else if (this.direction === "left") bx -= 2; else if (this.direction === "right") bx += 2;
        if (bx < 0 || bx >= W || by < 0 || by >= H) return null;
        return new Bullet(bx, by, this.direction);
      }

      hitByBullet(bullet) {
        const cords = this.getCordinates();
        for (const c of cords) if (bullet.pos_x === c.x && bullet.pos_y === c.y) return true;
        return false;
      }
    }

    /*******************
     * Game State & Controls
     *******************/
    let speed = 3000;     // enemy move interval (ms)
    let bulletSpeed = 100; // bullet step interval (ms)
    let score = 0;
    let level = 0;
    let status = "stop"; // start | pause | stop

    let hero = null;
    let enemies = [];
    let bullets = [];
    let allowFireBullet = true;

    const ranges = {
      upLeft: {min_x: 0 , max_x: 4, min_y: 0,  max_y: 9,  x: 1, y: 1,  direction: "down"},
      upRight:{min_x: 5 , max_x: 9, min_y: 0,  max_y: 9,  x: 8, y: 1,  direction: "left"},
      downLeft:{min_x: 0 , max_x: 4, min_y:10,  max_y:19, x: 1, y:18, direction: "right"},
      downRight:{min_x: 5 , max_x: 9, min_y:10,  max_y:19, x: 8, y:18, direction: "up"}
    };

    function spawnEnemiesIfNeeded() {
      if (enemies.length >= 4) return;
      const availableSite = {upLeft: 1, upRight: 1, downLeft: 1, downRight: 1};
      for (const [area, range] of Object.entries(ranges)) {
        if (hero.pos_x >= range.min_x && hero.pos_x <= range.max_x && hero.pos_y >= range.min_y && hero.pos_y <= range.max_y) availableSite[area] = 0;
        for (const e of enemies) if (e.pos_x >= range.min_x && e.pos_x <= range.max_x && e.pos_y >= range.min_y && e.pos_y <= range.max_y) availableSite[area] = 0;
      }
      for (const [area, value] of Object.entries(availableSite)) {
        if (value === 1) {
          const r = ranges[area];
          enemies.push(new Tank(r.x, r.y, true, r.direction));
          return;
        }
      }
    }

    function moveEnemies() {
      for (const enemy of enemies) {
        const xDiff = Math.abs(enemy.pos_x - hero.pos_x);
        const yDiff = Math.abs(enemy.pos_y - hero.pos_y);

        if (xDiff < 2) {
          enemy.move(enemy.pos_y > hero.pos_y ? "up" : "down");
          const b = enemy.getBullet(); if (b) bullets.push(b);
        } else if (yDiff < 2) {
          enemy.move(enemy.pos_x > hero.pos_x ? "left" : "right");
          const b = enemy.getBullet(); if (b) bullets.push(b);
        } else if (xDiff > yDiff) {
          enemy.move(enemy.pos_y > hero.pos_y ? "up" : "down");
        } else {
          enemy.move(enemy.pos_x > hero.pos_x ? "left" : "right");
        }
      }
      spawnEnemiesIfNeeded();
    }

    function moveBullets() {
      // advance bullets
      for (const b of bullets) b.moveForward();

      // remove invalid
      bullets = bullets.filter(b => b.isValid());

      // bullet vs hero
      if (hero) {
        const hit = bullets.find(b => hero.hitByBullet(b));
        if (hit) { gameOver(); return; }
      }

      // bullet vs enemies
      const survivors = [];
      for (const b of bullets) {
        let killed = false;
        for (let i = 0; i < enemies.length; i++) {
          if (enemies[i].hitByBullet(b)) {
            enemies.splice(i, 1);
            score++; document.getElementById("score").innerText = score;
            killed = true; break;
          }
        }
        if (!killed) survivors.push(b);
      }
      bullets = survivors;

      // bullet vs bullet (remove all bullets that share the same cell)
      const map = new Map();
      for (const b of bullets) {
        const key = b.pos_x + "," + b.pos_y;
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(b);
      }
      const finalBullets = [];
      for (const arr of map.values()) if (arr.length === 1) finalBullets.push(arr[0]);
      bullets = finalBullets;
    }

    function drawAll() {
      clearGrid();
      if (hero) markCoords(hero.getCordinates(), "active");
      for (const e of enemies) markCoords(e.getCordinates(), "active");
      for (const b of bullets) mark(b.pos_x, b.pos_y, "active");
      renderGrid();
    }

    // Controls
    function moveUp()   { if (status === "start" && hero) hero.move("up"); }
    function moveDown() { if (status === "start" && hero) hero.move("down"); }
    function moveLeft() { if (status === "start" && hero) hero.move("left"); }
    function moveRight(){ if (status === "start" && hero) hero.move("right"); }

    function fireShots() {
      if (status === 'start' && hero && allowFireBullet) {
        allowFireBullet = false;
        const b = hero.getBullet();
        if (b && b.isValid()) bullets.push(b);
        setTimeout(() => allowFireBullet = true, 300);
      }
    }

    function pause() {
      if (status === "start") {
        status = "pause";
        document.getElementById("message").innerText = "Game Paused..!";
        document.getElementById("pause").style = "display: none;";
        document.getElementById("resume").style = "";
      }
    }

    function resume() {
      if (status === "pause") {
        status = "start";
        document.getElementById("message").innerText = "Game Resumed..!";
        document.getElementById("pause").style = "";
        document.getElementById("resume").style = "display: none;";
        requestAnimationFrame(gameLoop);
      }
    }

    function gameOver() {
      document.getElementById("message").innerText = "Game Over..!";
      status = "stop";
    }

    function init() {
      speed = 3000;
      bulletSpeed = 100;
      level = 0;
      score = 0;
      status = "start";
      document.getElementById("level").innerText = level;
      document.getElementById("score").innerText = score;
      document.getElementById("message").innerText = "Game Started..!";
      document.getElementById("pause").style = "";
      document.getElementById("resume").style = "display: none;";

      hero = new Tank(2, H - 2, false, "up");
      enemies = [];
      bullets = [];
      spawnEnemiesIfNeeded();
      drawAll();
      requestAnimationFrame(gameLoop);
    }

    /*******************
     * Input handling
     *******************/
    function setupKeyUpListener(reloadFunc, spaceFunc, upKeyFunc, downKeyFunc, leftKeyFunc, rightKeyFunc) {
      document.addEventListener('keyup', (e) => {
        if (e.code === 'Enter') {
          spaceFunc();
        } else if (e.code === 'ArrowUp' || e.code === 'KeyW') {
          upKeyFunc();
        } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
          downKeyFunc();
        } else if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
          leftKeyFunc();
        } else if (e.code === 'ArrowRight' || e.code === 'KeyD') {
          rightKeyFunc();
        } else if (e.code === 'KeyR' || e.code === 'Delete') {
          reloadFunc();
        }
      });
    }

    document.addEventListener('keyup', (e) => { if (e.code === 'Space') fireShots(); });

    /*******************
     * Game loop (requestAnimationFrame)
     *******************/
    let lastBulletTime = 0;
    let lastMoveTime = 0;

    function gameLoop(ts) {
      if (status !== "start") return; // stop rendering when paused/stopped

      if (ts - lastBulletTime > bulletSpeed) { moveBullets(); lastBulletTime = ts; }
      if (ts - lastMoveTime > speed) { moveEnemies(); lastMoveTime = ts; }

      drawAll();
      requestAnimationFrame(gameLoop);
    }

    // Boot
    setupGamePanel("Tank");

    // Attach buttons
    document.getElementById("restartbtn").onclick = init;
    document.getElementById("pausebtn").onclick = pause;
    document.getElementById("resumebtn").onclick = resume;

    setupKeyUpListener(
      init,
      () => { if (status === "start") pause(); else if (status === "pause") resume(); },
      moveUp,
      moveDown,
      moveLeft,
      moveRight
    );

    // Start
    init();
  </script>
</body>
</html>
